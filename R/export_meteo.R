#' Export LakeEnsemblR standardized input to model specific driver format
#'
#'Export driver files for each model
#'
#' @param model vector; model to export driving data. Options include c('GOTM', 'GLM', 'Simstrat', 'FLake')
#' @param folder filepath; to folder which contains the model folders generated by export_config()
#' @param meteo_file filepath; to met file which is in the standardised LakeEnsemblR format.
#' @param lhc_file filepath to results from Latin Hypercube sampling from run_Latin_hypercube(). Defaults to NULL
#' @param metric character; metric to extract best scaling factors, can be 'RMSE', 'NSE', 'Pearson_r', 'MAE'. Defaults to RMSE
#' @param folder filepath; to folder which contains the model folders generated by export_config()
#'
#' @examples
#' \dontrun{
#' export_meteo(model = c('GOTM', 'GLM', 'Simstrat', 'FLake'), meteo_file = 'LakeEnsemblR_meteo_standard.csv')
#' }
#' @importFrom gotmtools get_yaml_value calc_cc input_yaml
#' @importFrom glmtools read_nml set_nml write_nml
#'
#' @export


export_meteo <- function(config_file, model = c('GOTM', 'GLM', 'Simstrat', 'FLake'), meteo_file, lhc_file = NULL, metric = 'RMSE', folder = '.'){

  # It's advisable to set timezone to GMT in order to avoid errors when reading time
  original_tz = Sys.getenv("TZ")
  Sys.setenv(TZ="GMT")

  # get lat and lon - currently hack getting from GOTM but maybe could be in global config file?
  yaml = file.path(folder,config_file)

  # Function to be added to gotmtools
  lat <- get_yaml_value(file = yaml, label = 'location', key = 'latitude')
  lon <- get_yaml_value(file = yaml, label = 'location', key = 'longitude')
  elev <- get_yaml_value(file = yaml, label = 'location', key = 'elevation')


  ### Import data
  # I'd prefer to use a function that can read both comma and tab delimited. data.table::fread does this, but then it's data.table
  message('Loading met data...')
  met = read.csv(file.path(folder,meteo_file), stringsAsFactors = F)
  met[,1] <- as.POSIXct(met[,1])
  # Check time step
  tstep <- diff(as.numeric(met[,1]))

  if((mean(tstep) - 86400)/86400 < -0.05){
    daily = FALSE
    subdaily = TRUE
  } else {
    daily = TRUE
    subdaily = FALSE
  }

  # # Is data daily? - For cloud cover calculation
  # if(sum(tstep != 86400) > 0){
  #   daily = FALSE
  #   subdaily = TRUE
  # }else{
  #   daily = TRUE
  #   subdaily = FALSE
  # }

  ### Naming conventions standard input
  # Depending on the setup of the standard config file, we can omit reading exact titles and read column numbers
  colname_time = "datetime"
  colname_wind_speed = "Ten_Meter_Elevation_Wind_Speed_meterPerSecond"
  colname_wind_direction = "Ten_Meter_Elevation_Wind_Direction_degree"
  colname_air_temperature = "Air_Temperature_celsius"
  colname_dewpoint_temperature = "Dewpoint_Temperature_celsius"
  colname_relative_humidity = "Relative_Humidity_percent"
  colname_solar_radiation = "Shortwave_Radiation_Downwelling_wattPerMeterSquared"
  colname_longwave_radiation = "Longwave_Radiation_Downwelling_wattPerMeterSquared"
  colname_surface_pressure = "Surface_Level_Barometric_Pressure_pascal"
  colname_precipitation = "Precipitation_meterPerSecond"
  colname_snow = "Snowfall_meterPerDay"
  colname_vapour_pressure = "Vapor_Pressure_milliBar"
  colname_cloud_cover = "Cloud_Cover_decimalFraction"

  ### Check what met data is available, as this determines what model forcing option to use (in the simstrat config file)
  datetime = colname_time %in% colnames(met)
  wind_speed = colname_wind_speed %in% colnames(met)
  wind_direction = colname_wind_direction %in% colnames(met)
  air_temperature = colname_air_temperature %in% colnames(met)
  solar_radiation = colname_solar_radiation %in% colnames(met)
  vapour_pressure = colname_vapour_pressure %in% colnames(met)
  relative_humidity = colname_relative_humidity %in% colnames(met)
  longwave_radiation = colname_longwave_radiation %in% colnames(met)
  cloud_cover = colname_cloud_cover %in% colnames(met)
  # Availability of precipitation data only used for snow module
  precipitation = colname_precipitation %in% colnames(met)
  snowfall = colname_snow %in% colnames(met)

  if(!is.null(lhc_file)){
    params <- read.csv(lhc_file)
    sub <- params[which(params[[metric]] < 2),]
    wind_factor <- mean(sub$wind_factor)
    swr_factor <- mean(sub$swr_factor)
    lw_factor <- mean(sub$lw_factor[sub$model %in% c('GLM', 'Simstrat')])

    message('Applying scaling factors:\nwind factor: ', signif(wind_factor,3), '\nswr factor: ', signif(swr_factor,3), '\nlw factor: ', signif(lw_factor,3))

    met$Ten_Meter_Elevation_Wind_Speed_meterPerSecond <- met$Ten_Meter_Elevation_Wind_Speed_meterPerSecond * wind_factor
    met$Shortwave_Radiation_Downwelling_wattPerMeterSquared <- met$Shortwave_Radiation_Downwelling_wattPerMeterSquared * swr_factor
    met$Longwave_Radiation_Downwelling_wattPerMeterSquared * lw_factor

  }

  # Met output file name
  met_outfile <- 'meteo_file.dat'

  # FLake
  #####
  if('FLake' %in% model){
    fla_met <- met

    # Humidity
    if(!vapour_pressure & relative_humidity){
      # Calculate vapour pressure as: relhum * saturated vapour pressure
      # Used formula for saturated vapour pressure from:
      # Woolway, R. I., Jones, I. D., Hamilton, D. P., Maberly, S. C., Muraoka, K., Read, J. S., . . . Winslow, L. A. (2015).
      # Automated calculation of surface energy fluxes with high-frequency lake buoy data.
      # Environmental Modelling & Software, 70, 191-198.

      fla_met[[colname_vapour_pressure]]=fla_met[[colname_relative_humidity]]/100 * 6.11 * exp(17.27 * fla_met[[colname_air_temperature]] / (237.3 + fla_met[[colname_air_temperature]]))

    }
    if(!cloud_cover){

      fla_met[[colname_cloud_cover]] =  calc_cc(date = fla_met$datetime,
                                                           airt = fla_met$Air_Temperature_celsius,
                                                           relh = fla_met$Relative_Humidity_percent,
                                                           swr = fla_met$Shortwave_Radiation_Downwelling_wattPerMeterSquared,
                                                           lat = lat, lon = lon,
                                                           elev = elev, # Needs to be added dynamically
                                                           daily = daily)

    }
    fla_met$index <- 1:nrow(fla_met)

    # Re-organise
    fla_met <- fla_met[,c('index','Shortwave_Radiation_Downwelling_wattPerMeterSquared','Air_Temperature_celsius', "Vapor_Pressure_milliBar", "Ten_Meter_Elevation_Wind_Speed_meterPerSecond", "Cloud_Cover_decimalFraction", "datetime")]
    fla_met$datetime <- format(fla_met$datetime, format = '%Y-%m-%d %H:%M:%S')
    colnames(fla_met)[1] <- paste0('!', colnames(fla_met)[1])

    # Write to file
    write.table(fla_met, file.path(folder, 'FLake', met_outfile), sep = '\t', quote = FALSE, col.names = FALSE, row.names = FALSE)

    # Input values to nml
    nml_file <- list.files(file.path(folder, 'FLake'))[grep('nml', list.files(file.path(folder, 'FLake')))]
    nml_file <- file.path(folder, 'FLake', nml_file)

    input_nml(nml_file, 'SIMULATION_PARAMS', 'time_step_number', nrow(fla_met))
    input_nml(nml_file, 'METEO', 'meteofile', paste0("'",met_outfile,"'"))

    message('FLake: Created file ', file.path(folder,"FLake", met_outfile))


  }

  # GLM
  #####
  if('GLM' %in% model){
    glm_met <- met

    # Convert units
    glm_met$Precipitation_meterPerDay <- glm_met$Precipitation_meterPerSecond * 86400

    # Subset data
    glm_met <- glm_met[,c('datetime','Shortwave_Radiation_Downwelling_wattPerMeterSquared', "Longwave_Radiation_Downwelling_wattPerMeterSquared", 'Air_Temperature_celsius', 'Relative_Humidity_percent', "Ten_Meter_Elevation_Wind_Speed_meterPerSecond", "Precipitation_meterPerDay", "Snowfall_meterPerDay")]

    colnames(glm_met) <- c('Date','ShortWave','LongWave','AirTemp','RelHum','WindSpeed','Rain','Snow')
    glm_met[,1] <- format(glm_met[,1], format = '%Y-%m-%d %H:%M:%S')

    # Write to file
    write.csv(glm_met, file.path('GLM', 'meteo_file.csv'), row.names = FALSE, quote = FALSE)

    if("LongWave" %in% colnames(glm_met)){
      lw_type = 'LW_IN'
    }else{
      lw_type = 'LW_IN' ### Needs to be developed catch if no LW
    }

    #
    # Note Jorrit 2019-12-14: : Why is this here? This should be defined in export_config. Removed setting start and stop in nml_list
    # start = glm_met[1,1]
    # stop = glm_met[nrow(glm_met),1]
    # # stop = '1980-01-01 00:00:00' # Added just for beta testing

    # Input to nml file
    nml_path <- file.path(folder, get_yaml_value(config_file, "config_files", "glm_config"))
    nml <- glmtools::read_nml(nml_path)

    nml_list <- list('subdaily' = subdaily, 'lw_type' = lw_type, 'meteo_fl' = 'meteo_file.csv')
    nml <- glmtools::set_nml(nml, arg_list = nml_list)

    glmtools::write_nml(nml, nml_path)
    message('GLM: Created file ', file.path(folder,"GLM", 'meteo_file.csv'))


  }

  ## GOTM
  if('GOTM' %in% model){
    met_got <- met
    yaml = file.path(folder,get_yaml_value(config_file, "config_files", "gotm_config"))

    # Function to be added to gotmtools
    lat <- get_yaml_value(file = yaml, label = 'location', key = 'latitude')
    lon <- get_yaml_value(file = yaml, label = 'location', key = 'longitude')

    if(wind_direction){
      direction=270-met_got[[colname_wind_direction]] # Converting the wind direction to the "math" direction
      rads=direction/180*pi
      xcomp=met_got[[colname_wind_speed]]*cos(rads)
      ycomp=met_got[[colname_wind_speed]]*sin(rads)
      met_got$Uwind = xcomp
      met_got$Vwind = ycomp
    }else{
      met_got$Uwind_meterPerSecond = met_got[[colname_wind_speed]]
      met_got$Vwind_meterPerSecond = 0
    }

    if(!cloud_cover){
      # Function from gotmtools

      met_got$Cloud_Cover_decimalFraction <- calc_cc(date = met_got$datetime, airt = met_got$Air_Temperature_celsius, relh = met_got$Relative_Humidity_percent, swr = met_got$Shortwave_Radiation_Downwelling_wattPerMeterSquared, lat = lat, lon = lon,
                                                                elev = elev, # Needs to be dynamically added
                                                                daily = daily)
    }

    met_got <- met_got[,c('datetime', 'Uwind_meterPerSecond', 'Vwind_meterPerSecond', 'Surface_Level_Barometric_Pressure_pascal', 'Air_Temperature_celsius', 'Relative_Humidity_percent', 'Cloud_Cover_decimalFraction', 'Shortwave_Radiation_Downwelling_wattPerMeterSquared', 'Precipitation_meterPerSecond')]

    colnames(met_got)[1] <- paste0('!', colnames(met_got)[1])
    met_got[,1] <- format(met_got[,1], '%Y-%m-%d %H:%M:%S')

    #Reduce number of digits
    met_got[,-1] <- signif(met_got[,-1], digits = 8)

    write.table(met_got, file.path('GOTM', met_outfile), quote = FALSE, row.names = FALSE, sep = '\t', col.names = TRUE)

    # Format gotm.yaml file
    ## Set gotm.yaml met config
    ######
    #u10
    input_yaml(file = yaml, label = 'u10', key = 'file', value = met_outfile)
    input_yaml(file = yaml, label = 'u10', key = 'column', value = (which(colnames(met_got) == "Uwind_meterPerSecond")-1))
    input_yaml(file = yaml, label = 'u10', key = 'scale_factor', value = 1)
    #v10
    input_yaml(file = yaml, label = 'v10', key = 'file', value = met_outfile)
    input_yaml(file = yaml, label = 'v10', key = 'column', value = (which(colnames(met_got) == "Vwind_meterPerSecond")-1))
    input_yaml(file = yaml, label = 'v10', key = 'scale_factor', value = 1)
    #airp
    input_yaml(file = yaml, label = 'airp', key = 'file', value = met_outfile)
    input_yaml(file = yaml, label = 'airp', key = 'column', value = (which(colnames(met_got) == "Surface_Level_Barometric_Pressure_pascal" )-1))
    input_yaml(file = yaml, label = 'airp', key = 'scale_factor', value = 1)
    #airt
    input_yaml(file = yaml, label = 'airt', key = 'file', value = met_outfile)
    input_yaml(file = yaml, label = 'airt', key = 'column', value = (which(colnames(met_got) == "Air_Temperature_celsius")-1))
    input_yaml(file = yaml, label = 'airt', key = 'scale_factor', value = 1)
    #cloud
    input_yaml(file = yaml, label = 'cloud', key = 'file', value = met_outfile)
    input_yaml(file = yaml, label = 'cloud', key = 'column', value = (which(colnames(met_got) == "Cloud_Cover_decimalFraction" )-1))
    input_yaml(file = yaml, label = 'cloud', key = 'scale_factor', value = 1)
    #swr
    input_yaml(file = yaml, label = 'swr', key = 'file', value = met_outfile)
    input_yaml(file = yaml, label = 'swr', key = 'column', value = (which(colnames(met_got) == "Shortwave_Radiation_Downwelling_wattPerMeterSquared")-1))
    input_yaml(file = yaml, label = 'swr', key = 'scale_factor', value = 1)
    #precip
    input_yaml(file = yaml, label = 'precip', key = 'file', value = met_outfile)
    input_yaml(file = yaml, label = 'precip', key = 'column', value = (which(colnames(met_got) == "Precipitation_meterPerSecond")-1))
    input_yaml(file = yaml, label = 'precip', key = 'scale_factor', value = 1)
    if("Relative_Humidity_percent" %in% colnames(met_got)){
      #hum
      input_yaml(file = yaml, label = 'hum', key = 'file', value = met_outfile)
      input_yaml(file = yaml, label = 'hum', key = 'column', value = (which(colnames(met_got) == "Relative_Humidity_percent")-1))
      input_yaml(file = yaml, label = 'hum', key = 'type', value = 1) #1=relative humidity (%), 2=wet-bulb temperature, 3=dew point temperature, 4=specific humidity (kg/kg)
      input_yaml(file = yaml, label = 'hum', key = 'scale_factor', value = 1)
    }
    if("Dewpoint_Temperature_celsius" %in% colnames(met_got)){
      #hum
      input_yaml(file = yaml, label = 'hum', key = 'file', value = met_outfile)
      input_yaml(file = yaml, label = 'hum', key = 'column', value = (which(colnames(met_got) == "Dewpoint_Temperature_celsius")-1))
      input_yaml(file = yaml, label = 'hum', key = 'type', value = 3) #1=relative humidity (%), 2=wet-bulb temperature, 3=dew point temperature, 4=specific humidity (kg/kg)
      input_yaml(file = yaml, label = 'hum', key = 'scale_factor', value = 1)
    }

    message('GOTM: Created file ', file.path(folder,"GOTM", met_outfile))


  }

  ## Simstrat
  if('Simstrat' %in% model){
    par_file <- file.path(folder, get_yaml_value(config_file, "config_files", "simstrat_config"))
    met_sim <- met

    # Required input file changes depending on the forcing mode in the config file
    forcing_mode <- get_json_value(par_file, "ModelConfig", "Forcing")

    ### Pre-processing
    # Time
    if(datetime){
      # Time in simstrat is in decimal days since a defined start year
      start_year <- get_json_value(par_file, "Simulation", "Start year")

      met_sim$datetime = as.numeric(difftime(met_sim$datetime,as.POSIXct(paste0(start_year,"-01-01")),units = "days"))
    }else{
      stop("Cannot find \"datetime\" column in the input file. Without this column, the model cannot run")
    }

    # Wind
    # If wind direction is provided, U and V wind components are calculated. If not, V wind is set to 0
    if(wind_direction){
      direction=270-met_sim[[colname_wind_direction]] # Converting the wind direction to the "math" direction
      rads=direction/180*pi
      xcomp=met_sim[[colname_wind_speed]]*cos(rads)
      ycomp=met_sim[[colname_wind_speed]]*sin(rads)
      met_sim$Uwind = xcomp
      met_sim$Vwind = ycomp
    }else{
      met_sim$Uwind_meterPerSecond = met_sim[[colname_wind_speed]]
      met_sim$Vwind_meterPerSecond = 0
    }

    # Humidity
    if(!vapour_pressure & relative_humidity){
      # Calculate vapour pressure as: relhum * saturated vapour pressure
      # Used formula for saturated vapour pressure from:
      # Woolway, R. I., Jones, I. D., Hamilton, D. P., Maberly, S. C., Muraoka, K., Read, J. S., . . . Winslow, L. A. (2015).
      # Automated calculation of surface energy fluxes with high-frequency lake buoy data.
      # Environmental Modelling & Software, 70, 191-198.

      met_sim[[colname_vapour_pressure]]=met_sim[[colname_relative_humidity]]/100 * 6.11 * exp(17.27 * met_sim[[colname_air_temperature]] / (237.3 + met_sim[[colname_air_temperature]]))

    }

    # If snow_module is true, there needs to be a precipitation (or snowfall) columnn.
    snow_module <- get_json_value(par_file, "ModelConfig", "SnowModel") == 1
    # Optionally, if there is no precipitation/snowfall column, we can set the snow_module to FALSE

    if(snow_module & !(precipitation | snowfall)){
      stop("There is no precipitation data and the Simstrat snow_module is set to TRUE.")
    }


    # Precipitation
    # Precipitation needs to be in m h-1: 1 m s-1 = 3600 m h-1, or 1 m d-1 = 1/24 m h-1
    if(precipitation){
      met_sim$`Precipitation_meterPerHour`=met_sim[[colname_precipitation]]*3600
    }else if(snowfall){
      met_sim$`Precipitation_meterPerHour`=met_sim[[colname_snow]]/24
    }




    ### Build simstrat_forcing file
    # Boolean to see if there is enough data to write the meteo file
    enoughData=T


    # Now build the simstrat forcing file, based on the forcing_mode. If data is not available, an error message is displayed
    if(forcing_mode == "5"){
      if(!(wind_speed & air_temperature & solar_radiation & (vapour_pressure | relative_humidity) & longwave_radiation)){
        enoughData = F
      }else{
        simstrat_forcing = met_sim[, c(colname_time, "Uwind_meterPerSecond", "Vwind_meterPerSecond",
                                   colname_air_temperature, colname_solar_radiation, colname_vapour_pressure,
                                   colname_longwave_radiation)]
        if(snow_module){
          simstrat_forcing[["Precipitation_meterPerHour"]] = met_sim[["Precipitation_meterPerHour"]]
        }
      }
    }else if(forcing_mode == "4"){
      # Forcing mode 4 requires one column with "heat flux" input. LakeEnsemblR does not yet have functionality for this option
      enoughData = F
    }else if(forcing_mode == "3"){
      if(!(wind_speed & air_temperature & solar_radiation & (vapour_pressure | relative_humidity) & cloud_cover)){
        enoughData = F
      }else{
        simstrat_forcing = met_sim[, c(colname_time, "Uwind_meterPerSecond", "Vwind_meterPerSecond",
                                   colname_air_temperature, colname_solar_radiation, colname_vapour_pressure,
                                   colname_cloud_cover)]
        if(snow_module){
          simstrat_forcing[["Precipitation_meterPerHour"]] = met_sim[["Precipitation_meterPerHour"]]
        }
      }
    }else if(forcing_mode == "2"){
      if(!(wind_speed & air_temperature & solar_radiation & (vapour_pressure | relative_humidity))){
        enoughData = F
      }else{
        simstrat_forcing = met_sim[, c(colname_time, "Uwind_meterPerSecond", "Vwind_meterPerSecond",
                                   colname_air_temperature, colname_solar_radiation, colname_vapour_pressure)]
        if(snow_module){
          simstrat_forcing[["Precipitation_meterPerHour"]] = met_sim[["Precipitation_meterPerHour"]]
        }
      }
    }else if(forcing_mode == "1"){
      if(!(wind_speed & air_temperature & solar_radiation)){
        enoughData = F
      }else{
        simstrat_forcing = met_sim[, c(colname_time, "Uwind_meterPerSecond", "Vwind_meterPerSecond",
                                   colname_air_temperature, colname_solar_radiation)]
        if(snow_module){
          simstrat_forcing[["Precipitation_meterPerHour"]] = met_sim[["Precipitation_meterPerHour"]]
        }
      }
    }

    if(!enoughData){stop(paste("There is no data to run the model in forcing mode",forcing_mode))}

    ### Write the table in the present working directory
    write.table(simstrat_forcing,file = file.path(folder,"Simstrat", met_outfile),sep = "\t",quote = F,row.names = F)
    input_json(file = par_file, label = 'Input', key = 'Forcing', '"meteo_file.dat"')

    message('Simstrat: Created file ', file.path(folder,"Simstrat", met_outfile))
  }

  # Set the timezone back to the original
  Sys.setenv(TZ=original_tz)


}
