#' Export LakeEnsemblR standardised flow files to model specific driver format
#'
#' Export in- anbd out-flow driver files for each model
#'
#' @param config_file filepath; to LakeEnsemblr yaml master config file
#' @param model vector; model to export driving data. Options include
#'    c("GOTM", "GLM", "Simstrat", "FLake", "MyLake")
#' @param folder filepath; to folder which contains the model folders generated by export_config()
#'
#' @examples
#' \dontrun{
#' export_flow(config_file, model = c("GOTM", "GLM", "Simstrat", "FLake", "MyLake"))
#' }
#' @importFrom gotmtools get_yaml_value calc_cc input_yaml
#' @importFrom glmtools read_nml set_nml write_nml
#'
#' @export
export_flow <- function(config_file, model = c("GOTM", "GLM", "Simstrat", "FLake", "MyLake"),
                          folder = ".") {

  # It's advisable to set timezone to GMT in order to avoid errors when reading time
  original_tz  <-  Sys.getenv("TZ")
  Sys.setenv(TZ = "UTC")

  # Set working directory
  oldwd <- getwd()
  setwd(folder)

  # this way if the function exits for any reason, success or failure, these are reset:
  on.exit({
    setwd(oldwd)
    Sys.setenv(TZ = original_tz)
  })

  # check model input
  model <- check_models(model)

##-------------Read settings---------------
  # initial water level
  init_lvl <- get_yaml_value(config_file, "location", "init_depth")
  # surface elevation
  surf_lvl <- get_yaml_value(config_file, "location", "elevation")
  # bottom elevation
  bot_lvl <- surf_lvl - get_yaml_value(config_file, "location", "depth")

  # Get start & stop dates
  start_date <- get_yaml_value(config_file, "time", "start")
  stop_date <- get_yaml_value(config_file, "time", "stop")

  # Use inflows
  use_inflows <- get_yaml_value(config_file, "inflows", "use")
  
  # Use outflows
  tryCatch({get_yaml_value(config_file, "inflows", "mass-balance")
    warning(paste0("The 'mass-balance' argument is no longer used after ",
                   "version 1.1. If you would like to have outflows ",
                   "matching the inflows, please add the inflow file ",
                   "manually to the 'outflows' section. You can use the same ",
                   "or a different file as for inflows."))},
    error = function(e) { })
  
  use_outflows <- get_yaml_value(config_file, "outflows", "use")

  if(use_outflows) {
    # number of outflows
    num_outflows <- get_yaml_value(config_file, "outflows", "number_outflows")
    # outflow depths
    lvl_outflows <- get_yaml_value(config_file, "outflows", "outflow_lvl")
    # Get scaling parameter
    scale_param_out <- get_yaml_value(config_file, "outflows", "scale_param")
  }

  if(use_inflows) {
    # Get scaling parameter
    scale_param_inf <- get_yaml_value(config_file, "inflows", "scale_param")
    # number of inflows
    num_inflows <- get_yaml_value(config_file, "inflows", "number_inflows")
  }


##---------------FLake-------------

  if("FLake" %in% model){
    fla_fil <- file.path(folder, get_yaml_value(config_file, "config_files", "FLake"))

    if(!use_inflows){
      input_nml(fla_fil, label = "inflow", key = "Qfromfile",  ".false.")
    }else{
      input_nml(fla_fil, label = "inflow", key = "Qfromfile",  ".true.")
    }
  }

##---------------GLM-------------

  if("GLM" %in% model){
    glm_nml <- file.path(folder, get_yaml_value(config_file, "config_files", "GLM"))

    # Read in nml and input parameters
    nml <- read_nml(glm_nml)
    # if no inflow or outflow is used  this list is keep otherwise it is changed
    inp_list <- list("num_inflows" = 0, "num_outlet" = 0)
    # set inflow
    if (use_inflows) {
      inp_list$num_inflows  <-  num_inflows
      inp_list <- c(inp_list, list("names_of_strms" = paste0("inflow_", 1:num_inflows),
                                   "strm_hf_angle" = rep(65, num_inflows),
                                   "strmbd_slope" = rep(2, num_inflows),
                                   "strmbd_drag" = rep(0.016, num_inflows),
                                   "inflow_factor" = rep(1, num_inflows),
                                   "inflow_fl" = paste0("inflow_", 1:num_inflows, ".csv")))
    }

    # set outflows
    if (use_outflows){
      outf_surf <- rep(FALSE, num_outflows)
      outf_surf[lvl_outflows == -1] <- TRUE
      #!! outflow elevations need to be in meters above sea level!!
      lvl_outflows_glm <- lvl_outflows + bot_lvl
      # outflow lvl for floating outflows is set to 0
      lvl_outflows_glm[lvl_outflows == -1] <- 0
      inp_list$num_outlet <- num_outflows
      inp_list <- c(inp_list, list("flt_off_sw" = outf_surf,
                                   "outl_elvs" = lvl_outflows_glm,
                                   "outflow_fl" = paste0("outflow_", 1:num_outflows, ".csv"),
                                   "outflow_factor" = rep(1, num_outflows)))
    }

    nml <- glmtools::set_nml(nml, arg_list = inp_list)
    write_nml(nml, glm_nml)

  }

##---------------GOTM-------------

  if("GOTM" %in% model) {
    got_yaml <- file.path(folder, get_yaml_value(config_file, "config_files", "GOTM"))
    yml_no_comment <- unname(sapply(readLines(got_yaml), function(x) strsplit(x, "#")[[1]][1]))
    # number of inflows in the yaml file so far
    num_inf_yaml <- length(grep("inflow\\_*\\d*:", yml_no_comment, value = TRUE))

    # number of outflows in the yaml file so far
    num_outf_yaml <- length(grep("outflow\\_*\\d*:", yml_no_comment, value = TRUE))


    ## Switch off streams
    if(!use_inflows) {
      # switch of flexible water level
      input_yaml_multiple(got_yaml, key1 = "mimic_3d", key2 = "zeta", key3 = "method",
                          value = 0)
      input_yaml_multiple(got_yaml, key1 = "water_balance_method", value = 0)
      # remove all inflows but one
      if (num_inf_yaml > 1) {
        for (i in 2:(num_inf_yaml)) {
          rm_yaml_sec(got_yaml, paste0("inflow_", i))
          num_inf_yaml <- 1
        }
      }
      # streams_switch(file = got_yaml, method = "off")
      input_yaml_multiple(got_yaml, key1 = "streams", key2 = "inflow", key3 = "flow", key4 =
                            "method", value = 0)
      input_yaml_multiple(got_yaml, key1 = "streams", key2 = "inflow", key3 = "temp", key4 =
                            "method", value = 0)
      input_yaml_multiple(got_yaml, key1 = "streams", key2 = "inflow", key3 = "salt", key4 =
                            "method", value = 0)
    }
    if (!use_outflows) {
      # remove all outflows but one
      if (num_outf_yaml > 1) {
        for (i in 2:(num_outf_yaml)) {
          rm_yaml_sec(got_yaml, paste0("outflow_", i))
          num_outf_yaml <- 1
        }
      }
      input_yaml_multiple(got_yaml, key1 = "streams", key2 = "outflow", key3 = "flow", key4 =
                            "method", value = 0)
      input_yaml_multiple(got_yaml, key1 = "streams", key2 = "outflow", key3 = "temp", key4 =
                            "method", value = 0)
      input_yaml_multiple(got_yaml, key1 = "streams", key2 = "outflow", key3 = "salt", key4 =
                            "method", value = 0)
    }
    # set inflows
    if (use_inflows) {
      # switch on flexible water level
      input_yaml_multiple(got_yaml, key1 = "mimic_3d", key2 = "zeta", key3 = "method",
                          value = 3)
      input_yaml_multiple(got_yaml, key1 = "water_balance_method", value = 3)
      # remove additional inflows that are not needed
      if (num_inf_yaml > num_inflows) {
        for (i in 2:(num_inf_yaml)) {
          rm_yaml_sec(got_yaml, paste0("inflow_", i))
          num_inf_yaml <- 1
        }
      }
      # add additional inflows if necessary
      if(num_inflows > 1 & num_inflows != num_inf_yaml) {
        for (i in num_inflows:2) {
          doubl_yaml_sec(got_yaml, "inflow", paste0("_", i))
          num_inf_yaml <- num_inflows
        }
      }
        # set inflow settings for all inflows
        for (i in 1:num_inflows) {

          if(i == 1) {
            inf_sec <- "inflow"
          } else {
            inf_sec <- paste0("inflow_", i)
          }

          # streams_switch(file = got_yaml, method = "on")
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = inf_sec, key3 = "flow", key4 =
                                "method", value = 2)
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = inf_sec, key3 = "temp", key4 =
                                "method", value = 2)
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = inf_sec, key3 = "salt", key4 =
                                "method", value = 2)
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = inf_sec, key3 = "flow", key4 =
                                "file", value = paste0("inflow_file_", i, ".dat"))
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = inf_sec, key3 = "temp", key4 =
                                "file", value = paste0("inflow_file_", i, ".dat"))
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = inf_sec, key3 = "salt", key4 =
                                "file", value = paste0("inflow_file_", i, ".dat"))
        }
      }

    # set outflows
    if (use_outflows) {
      if (!use_inflows) {
        # switch on flexible water level
        input_yaml_multiple(got_yaml, key1 = "mimic_3d", key2 = "zeta", key3 = "method",
                            value = 3)
        input_yaml_multiple(got_yaml, key1 = "water_balance_method", value = 3)
      }
      # remove additional outflows that are not needed
      if (num_outf_yaml > num_outflows) {
        for (i in 2:(num_outf_yaml)) {
          rm_yaml_sec(got_yaml, paste0("outflow_", i))
          num_outf_yaml <- 1
        }
      }
      outf_surf <- rep(FALSE, num_outflows)
      outf_surf[lvl_outflows == -1] <- TRUE
      # outflow lvl in GOTM are meters below initial surface lvl
      lvl_outflows_gotm <- lvl_outflows - init_lvl
      # add additional outflows if necessary
      if(num_outflows > 1 & num_outflows != num_outf_yaml) {
        for (i in num_outflows:2) {
          doubl_yaml_sec(got_yaml, "outflow", paste0("_", i))
          num_outf_yaml <- num_outflows
        }
      }
        # set outflow settings for all outflows
        for (i in 1:num_outflows) {
          if(i == 1) {
            outf_sec <- "outflow"
          } else {
            outf_sec <- paste0("outflow_", i)
          }
          # streams_switch(file = got_yaml, method = "on")
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = outf_sec, key3 = "method",
                              value = ifelse(outf_surf[i], 1, 3))
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = outf_sec, key3 = "zl",
                              value = lvl_outflows_gotm[i] - 0.5)
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = outf_sec, key3 = "zu",
                              value = lvl_outflows_gotm[i] + 0.5)
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = outf_sec, key3 = "flow", key4 =
                                "method", value = 2)
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = outf_sec, key3 = "temp", key4 =
                                "method", value = 0)
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = outf_sec, key3 = "salt", key4 =
                                "method", value = 0)
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = outf_sec, key3 = "flow", key4 =
                                "file", value = paste0("outflow_file_", i, ".dat"))
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = outf_sec, key3 = "temp", key4 =
                                "file", value = paste0("outflow_file_", i, ".dat"))
          input_yaml_multiple(got_yaml, key1 = "streams", key2 = outf_sec, key3 = "salt", key4 =
                                "file", value = paste0("outflow_file_", i, ".dat"))
      }
    }
   }

##---------------Simstrat-------------

  if("Simstrat" %in% model){
    sim_par <- file.path(folder, get_yaml_value(config_file, "config_files", "Simstrat"))
    # Turn off inflow
    if(!use_inflows){
      ## Set Qin and Qout to 0 inflow
      inflow_line_1 <- "Time [d]\tQ_in [m3/s]"
      # In case Kw is a single value for the whole simulation:
      inflow_line_2 <- "1"
      inflow_line_3 <- "-1\t0.00"
      start_sim <- get_json_value(sim_par, "Simulation", "Start d")
      end_sim <- get_json_value(sim_par, "Simulation", "End d")
      inflow_line_4 <- paste0(start_sim, "\t", 0.000)
      inflow_line_5 <- paste0(end_sim, "\t", 0.000)

      file_connection <- file("Simstrat/Qin.dat")
      writeLines(c(inflow_line_1, inflow_line_2, inflow_line_3, inflow_line_4, inflow_line_5),
                 file_connection)
      close(file_connection)
      file_connection <- file("Simstrat/Qout.dat")
      writeLines(c(inflow_line_1, inflow_line_2, inflow_line_3, inflow_line_4, inflow_line_5),
                 file_connection)
      close(file_connection)
    }
    if(!use_outflows){
      outflow_outfile <- "Qout.dat"

      outflow_outfpath <- file.path(folder, "Simstrat", outflow_outfile)

      outflow_line_1 <- "Time [d]\tQ_out [m3/s]"
      outflow_line_2 <- "1"
      outflow_line_3 <- "-1\t0.00"
      start_sim <- get_json_value(sim_par, "Simulation", "Start d")
      end_sim <- get_json_value(sim_par, "Simulation", "End d")
      outflow_line_4 <- paste0(start_sim, "\t", 0.000)
      outflow_line_5 <- paste0(end_sim, "\t", 0.000)
      file_connection <- file(outflow_outfpath)
      writeLines(c(outflow_line_1, outflow_line_2, outflow_line_3, outflow_line_4,
                   outflow_line_5), file_connection)
      close(file_connection)
    }
  }

##---------------MyLake-------------

  if("MyLake" %in% model){
    # Load config file MyLake
    load(get_yaml_value(config_file, "config_files", "MyLake"))

    if(!use_inflows){
      mylake_config[["Inflw"]] <- matrix(rep(0, 8 * length(seq.POSIXt(from = as.POSIXct(start_date),
                                                                    to = as.POSIXct(stop_date),
                                                                    by = "day"))),
                                         ncol = 8)

      # save lake-specific config file for MyLake
      temp_fil <- gsub(".*/", "", get_yaml_value(config_file, "config_files", "MyLake"))
      save(mylake_config, file = file.path(folder, "MyLake", temp_fil))
    }
  }

##-------------If inflow == TRUE---------------

  if(use_inflows == TRUE){
    inflow_file <- get_yaml_value(file = config_file, label = "inflows", key = "file")
    # Check if file exists
    if(!file.exists(inflow_file)){
      stop(inflow_file, " does not exist. Check filepath in ", config_file)
    }
    ### Import data
    message("Loading inflow data...")
    inflow <- read.csv(file.path(folder, inflow_file), stringsAsFactors = FALSE)
    inflow[, 1] <- as.POSIXct(inflow[, 1])
    start_date <- get_yaml_value(config_file, "time", "start")
    # Stop date
    stop_date <- get_yaml_value(config_file, "time", "stop")
    inflow_start <- which(inflow$datetime == as.POSIXct(start_date))
    inflow_stop <- which(inflow$datetime == as.POSIXct(stop_date))
    inflow <- inflow[inflow_start:inflow_stop, ]

    ### Naming conventions standard input
    chk_names_flow(inflow, num_inflows, inflow_file)

    ### Apply scaling
    inflow <- scale_flow(inflow, num_inflows, scale_param_inf)

    # if multiple inflows are present put them in a list
    if(num_inflows > 1) {
      inflow_ls <- list()
      for (i in 1:num_inflows) {
        inflow_ls[[paste0("inflow_", i)]] <-
          data.frame(datetime = inflow$datetime,
                     Flow_metersCubedPerSecond = inflow[[paste0("Flow_metersCubedPerSecond_", i)]],
                     Water_Temperature_celsius = inflow[[paste0("Water_Temperature_celsius_", i)]],
                     Salinity_practicalSalinityUnits =
                       inflow[[paste0("Salinity_practicalSalinityUnits_", i)]]
                     )
      }
      inflow <- inflow_ls
      rm(inflow_ls)
    } else {
      inflow <- list(inflow_1 = inflow)
    }

    ##### FLake
    if("FLake" %in% model){


      flake_inflow <- format_inflow(inflow = inflow, model = "FLake", config_file = config_file)

      flake_outfile <- "Tinflow"

      flake_outfpath <- file.path(folder, "FLake", flake_outfile)

      write.table(flake_inflow, flake_outfpath, quote = FALSE, row.names = FALSE, sep = "\t",
                  col.names = FALSE)


      temp_fil <- get_yaml_value(config_file, "config_files", "FLake")
      input_nml(temp_fil, label = "inflow", key = "time_step_number", nrow(flake_inflow))

      message("FLake: Created file ", file.path(folder, "FLake", flake_outfile))


    }

    ###### GLM
    if("GLM" %in% model){
      for (i in 1:num_inflows) {
        glm_inflow <- format_inflow(inflow = inflow[[i]], model = "GLM",
                                    config_file = config_file)

        inflow_outfile <- file.path("GLM", paste0("inflow_", i, ".csv"))
        write.csv(glm_inflow, inflow_outfile, row.names = FALSE, quote = FALSE)
        message("GLM: Created file ", file.path(folder, "GLM", paste0("inflow_", i, ".csv")))
      }
    }

    ##### GOTM
    if("GOTM" %in% model){

      for (i in 1:num_inflows) {
        gotm_outfile <- paste0("inflow_file_", i, ".dat")
        gotm_outfpath <- file.path(folder, "GOTM", gotm_outfile)
        gotm_inflow <- format_inflow(inflow[[i]], model = "GOTM", config_file = config_file)

        write.table(gotm_inflow, gotm_outfpath, quote = FALSE, row.names = FALSE, sep = "\t",
                    col.names = TRUE)

        message("GOTM: Created file ", file.path(folder, "GOTM", gotm_outfile))
      }

    }

    ## Simstrat
    if("Simstrat" %in% model){
      # output file names
      inflow_outfile <- "Qin.dat"
      temp_outfile <- "Tin.dat"
      salt_outfile <- "Sin.dat"
      # output file paths
      inflow_outfpath <- file.path(folder, "Simstrat", inflow_outfile)
      temp_outfpath <- file.path(folder, "Simstrat", temp_outfile)
      salt_outfpath <- file.path(folder, "Simstrat", salt_outfile)

      sim_inflow <- format_inflow(inflow = inflow, model = "Simstrat", config_file = config_file)

      ## inflow file
      inflow_line_1 <- "Time [d]\tQ_in [m3/s]"
      inflow_line_2 <- as.character(num_inflows)
      inflow_line_3 <- paste0("-1",  rep("\t0.00", num_inflows))
      if(num_inflows > 1) {
        inflow_line_4 <- seq_len(length(sim_inflow$datetime))
        for (i in 1:num_inflows) {
          inflow_line_4 <- paste0(inflow_line_4, "\t",
                                 sim_inflow[, paste0("Flow_metersCubedPerSecond_", i)])
        }
      } else {
        inflow_line_4 <- paste0(seq_len(length(sim_inflow$datetime)), "\t",
                               sim_inflow$Flow_metersCubedPerSecond)
      }
      file_connection <- file(inflow_outfpath)
      writeLines(c(inflow_line_1, inflow_line_2, inflow_line_3, inflow_line_4), file_connection)
      close(file_connection)
      # temperature file
      inflow_line_1 <- "Time [d]\tT_in [degC]"
      if(num_inflows > 1) {
        inflow_line_4 <- seq_len(length(sim_inflow$datetime))
        for (i in 1:num_inflows) {
          inflow_line_4 <- paste0(inflow_line_4, "\t",
                                 sim_inflow[, paste0("Water_Temperature_celsius_", i)])
        }
      } else {
        inflow_line_4 <- paste0(seq_len(length(sim_inflow$datetime)), "\t",
                               sim_inflow$Water_Temperature_celsius)
      }
      file_connection <- file(temp_outfpath)
      writeLines(c(inflow_line_1, inflow_line_2, inflow_line_3, inflow_line_4), file_connection)
      close(file_connection)
      # salinity file
      inflow_line_1 <- "Time [d]\tS_in [perMille]"
      if(num_inflows > 1) {
        inflow_line_4 <- seq_len(length(sim_inflow$datetime))
        for (i in 1:num_inflows) {
          inflow_line_4 <- paste0(inflow_line_4, "\t",
                                 sim_inflow[, paste0("Salinity_practicalSalinityUnits_", i)])
        }
      } else {
        inflow_line_4 <- paste0(seq_len(length(sim_inflow$datetime)), "\t",
                               sim_inflow$Salinity_practicalSalinityUnits)
      }
      file_connection <- file(salt_outfpath)
      writeLines(c(inflow_line_1, inflow_line_2, inflow_line_3, inflow_line_4),
                 file_connection)
      close(file_connection)

      message("Simstrat: Created file ", file.path(folder, "Simstrat", inflow_outfile))
    }

    ## MyLake
    if("MyLake" %in% model){

      temp_fil <- get_yaml_value(config_file, "config_files", "MyLake")
      load(temp_fil)

      mylake_inflow <- format_inflow(inflow = inflow, model = "MyLake",
                                     config_file = config_file)

      # discharge [m3/d], temperature [deg C], conc of passive tracer [-], conc of passive
      # sediment tracer [-], TP [mg/m3], DOP [mg/m3], Chla [mg/m3], DOC [mg/m3]
      dummy_inflow <- matrix(rep(1e-10, 8 *
                                   length(seq.POSIXt(from = as.POSIXct(start_date),
                                                            to = as.POSIXct(stop_date),
                                                            by = "day"))),
                             ncol = 8)
      dummy_inflow[, 1] <- mylake_inflow$Flow_metersCubedPerDay
      dummy_inflow[, 2] <- mylake_inflow$Water_Temperature_celsius
      dummy_inflow[, 5] <- dummy_inflow[, 5] * 1e7
      dummy_inflow[, 6] <- dummy_inflow[, 6] * 1e1


      mylake_config[["Inflw"]] <- dummy_inflow

      temp_fil <- gsub(".*/", "", temp_fil)
      # save lake-specific config file for MyLake
      save(mylake_config, file = file.path(folder, "MyLake", temp_fil))

      message("MyLake: Created file ", file.path(folder, "MyLake", temp_fil))

    }
  }

  ##-------------If outflow == TRUE---------------

  if(use_outflows == TRUE) {

    outflow_file <- get_yaml_value(file = config_file, label = "outflows", key = "file")
    # Check if file exists
    if(!file.exists(outflow_file)){
      stop(outflow_file, " does not exist. Check filepath in ", config_file)
    }

    ### Import data
    message("Loading outflow data...")
    outflow <- read.csv(file.path(folder, outflow_file), stringsAsFactors = FALSE)
    outflow[, 1] <- as.POSIXct(outflow[, 1])

    start_date <- get_yaml_value(config_file, "time", "start")
    # Stop date
    stop_date <- get_yaml_value(config_file, "time", "stop")

    outflow_start <- which(outflow$datetime == as.POSIXct(start_date))
    outflow_stop <- which(outflow$datetime == as.POSIXct(stop_date))

    outflow <- outflow[outflow_start:outflow_stop, ]

    ### Naming conventions standard input
    chk_names_flow(outflow, num_outflows, outflow_file)

    ### Apply scaling
    outflow <- scale_flow(outflow, num_outflows, scale_param_out)

    # if multiple outflows are present put them in a list
    if(num_outflows > 1) {
      outflow_ls <- list()
      for (i in 1:num_outflows) {
        outflow_ls[[paste0("outflow_", i)]] <-
          data.frame(datetime = outflow$datetime,
                     Flow_metersCubedPerSecond = outflow[[paste0("Flow_metersCubedPerSecond_", i)]])
      }
      outflow <- outflow_ls
      rm(outflow_ls)
    } else {
      outflow <- list(outflow_1 = outflow)
    }

    # FLake
    #####
    if("FLake" %in% model) {
        message("FLake does not need outflows, as mass fluxes are not considered.")
    }

    # GLM
    #####
    if("GLM" %in% model) {
      for (i in 1:num_outflows) {
        glm_outflow <- format_outflow(outflow = outflow[[i]], model = "GLM",
                                    config_file = config_file)

        outflow_outfile <- file.path("GLM", paste0("outflow_", i, ".csv"))
        write.csv(glm_outflow, outflow_outfile, row.names = FALSE, quote = FALSE)
        message("GLM: Created file ", file.path(folder, "GLM", paste0("outflow_", i, ".csv")))
      }
    }

    ## GOTM
    if("GOTM" %in% model) {

      for (i in 1:num_outflows) {

        gotm_outfile <- paste0("outflow_file_", i, ".dat")

        gotm_outfpath <- file.path(folder, "GOTM", gotm_outfile)

        gotm_outflow <- format_outflow(outflow[[i]], model = "GOTM", config_file = config_file)
        write.table(gotm_outflow, gotm_outfpath, quote = FALSE, row.names = FALSE, sep = "\t",
                    col.names = TRUE)

        message("GOTM: Created file ", file.path(folder, "GOTM", gotm_outfile))
      }
    }

    ## Simstrat
    if("Simstrat" %in% model) {

      outf_surf <- rep(FALSE, num_outflows)
      outf_surf[lvl_outflows == -1] <- TRUE
      #!! outflow elevations need to be relative to initial water level!!
      lvl_outflows_simstrat <- round(lvl_outflows - init_lvl)
      lvl_outflows_simstrat[outf_surf] <- -1

      # if there are several outflows with the same depth throw an error
      if(any(duplicated(lvl_outflows_simstrat))) {
        stop(paste0("Duplicated outflow levels in simstrat detected, please merge outflows",
                    " at 1m intervals."))
      }
      
      # add withdrawal depth below and above the given withdrawals for deep withdrawal
      zerowith <- c(lvl_outflows_simstrat[!outf_surf] - 1,
                    lvl_outflows_simstrat[!outf_surf] + 1, 0)
      zerowith <- zerowith[zerowith <= 0]
      zerowith <- unique(zerowith)
      zerowith <- zerowith[!(zerowith %in% lvl_outflows_simstrat[!outf_surf])]
      
      # merge zero flow with outflows for the deep outflows
      lvl_outflows_simstrat_deep <- sort(c(zerowith, lvl_outflows_simstrat[!outf_surf]))
      
      outflow_outfile <- "Qout.dat"

      outflow_outfpath <- file.path(folder, "Simstrat", outflow_outfile)
      sim_outflow <- format_outflow(outflow, "Simstrat", config_file, folder)
      ## inflow file
      outflow_line_1 <- "Time [d]\tQ_out [m3/s]"
      outflow_line_2 <- paste0(as.character(length(lvl_outflows_simstrat_deep)), "\t",
                               as.character(sum(outf_surf) + 1))
      outflow_line_3 <- paste0("-1\t",  paste0(lvl_outflows_simstrat_deep, collapse = "\t"),
                               "\t", paste0(lvl_outflows_simstrat[outf_surf], collapse = "\t"),
                               "\t0")
      if(num_outflows > 1 | all(!outf_surf)) {
        outflow_line_4 <- seq_len(length(sim_outflow$datetime))
        # first the deep outflows
        for (i in seq_len(length(lvl_outflows_simstrat_deep))) {
          if(lvl_outflows_simstrat_deep[i] %in% lvl_outflows_simstrat[!outf_surf]) {
            j <- which(lvl_outflows_simstrat[!outf_surf] %in% lvl_outflows_simstrat_deep[i])
            outflow_line_4 <- paste0(outflow_line_4, "\t",
                                     sim_outflow[, paste0("Flow_metersCubedPerSecond_", j)])
          } else {
            outflow_line_4 <- paste0(outflow_line_4, "\t", rep(0, length(sim_outflow$datetime)))
          }
          
        }
        if(any(outf_surf)) {
          # then the surface oputflows
          for (i in ((1:num_outflows)[outf_surf])) {
            outflow_line_4 <- paste0(outflow_line_4, "\t",
                                    sim_outflow[, paste0("Flow_metersCubedPerSecond_", i)])
            outflow_line_4 <- paste0(outflow_line_4, "\t",
                                     sim_outflow[, paste0("Flow_metersCubedPerSecond_", i)])
          }
        }
      } else {
        outflow_line_4 <- paste0(seq_len(length(sim_outflow$datetime)), "\t",
                                sim_outflow$Flow_metersCubedPerSecond)
      }
      file_connection <- file(outflow_outfpath)
      writeLines(c(outflow_line_1, outflow_line_2, outflow_line_3, outflow_line_4), file_connection)
      close(file_connection)

      message("Simstrat: Created outflow file ", file.path(folder, "Simstrat", outflow_outfile))
    }

    ## MyLake
    if("MyLake" %in% model) {

        message("MyLake does not need specific outflows, as it employs automatic overflow.")
  }


  message("export_flow complete!")
  }
}
